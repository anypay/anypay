import knex, { Knex } from 'knex';
import { promises as fs } from 'fs';

export class SchemaMigrator {
    private db: Knex;

    constructor(connectionString: string) {
        this.db = knex({
            client: 'pg',
            connection: connectionString,
        });
    }

    private async getColumnDefinition(column: any): Promise<string> {
        let sql = `${column.column_name} ${column.data_type}`;
        
        if (column.character_maximum_length) {
            sql += `(${column.character_maximum_length})`;
        }
        
        if (column.is_nullable === 'NO') {
            sql += ' NOT NULL';
        }
        
        if (column.column_default) {
            sql += ` DEFAULT ${column.column_default}`;
        }
        
        return sql;
    }

    private async getTableSchema(tableName: string): Promise<string> {
        // Get columns
        const columns = await this.db('information_schema.columns')
            .where({
                table_name: tableName,
                table_schema: 'public'
            })
            .orderBy('ordinal_position');

        // Get primary key
        const primaryKey = await this.db('information_schema.key_column_usage')
            .join('information_schema.table_constraints', function() {
                this.on('key_column_usage.constraint_name', '=', 'table_constraints.constraint_name')
                    .andOn('key_column_usage.table_name', '=', 'table_constraints.table_name');
            })
            .where({
                'table_constraints.table_name': tableName,
                'table_constraints.constraint_type': 'PRIMARY KEY',
                'table_constraints.table_schema': 'public'
            })
            .select('key_column_usage.column_name');

        const columnDefinitions = await Promise.all(
            columns.map(col => this.getColumnDefinition(col))
        );

        let createTable = `CREATE TABLE ${tableName} (\n`;
        createTable += columnDefinitions.join(',\n    ');

        if (primaryKey.length > 0) {
            const pkColumns = primaryKey.map(pk => pk.column_name);
            createTable += `,\n    PRIMARY KEY (${pkColumns.join(', ')})`;
        }

        createTable += '\n);';
        return createTable;
    }

    private async getIndexSchema(tableName: string): Promise<string[]> {
        const indexes = await this.db.raw(`
            SELECT
                i.relname as index_name,
                ix.indisunique as is_unique,
                array_agg(a.attname) as column_names
            FROM
                pg_class t,
                pg_class i,
                pg_index ix,
                pg_attribute a
            WHERE
                t.oid = ix.indrelid
                AND i.oid = ix.indexrelid
                AND a.attrelid = t.oid
                AND a.attnum = ANY(ix.indkey)
                AND t.relkind = 'r'
                AND t.relname = ?
            GROUP BY
                i.relname,
                ix.indisunique;
        `, [tableName]);

        return indexes.rows.map((index: any) => {
            const indexType = index.is_unique ? 'UNIQUE INDEX' : 'INDEX';
            const columns = index.column_names.join(', ');
            return `CREATE ${indexType} ${index.index_name} ON ${tableName} (${columns});`;
        });
    }

    public async generateMigrationScript(outputFile: string): Promise<void> {
        try {
            let script = '-- Migration script generated by Schema Migrator\n\n';

            // Get all tables
            const tables = await this.db('information_schema.tables')
                .where({ table_schema: 'public', table_type: 'BASE TABLE' })
                .select('table_name');

            for (const table of tables) {
                const tableName = table.table_name;
                
                script += `-- Table: ${tableName}\n`;
                script += await this.getTableSchema(tableName);
                script += '\n\n';

                const indexes = await this.getIndexSchema(tableName);
                if (indexes.length > 0) {
                    script += `-- Indexes for table: ${tableName}\n`;
                    script += indexes.join('\n');
                    script += '\n\n';
                }
            }

            await fs.writeFile(outputFile, script);
        } finally {
            await this.db.destroy();
        }
    }
}